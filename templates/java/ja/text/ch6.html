<h1>第6章ループ中</h1>
<hr/>
<p>新しいメソッドを定義し、forループを定義するというテクニックは、実際のところ有用ですが、実際にはKarelが新しい問題を解決することはできません。あなたがプログラムを実行するrun 、常に同じことが行われます。プログラムは、異なる入力に対して異なる応答をすることができる場合には、はるかに便利になります。</p>
<p>例として。あなたが壁にKarel moveを持っているためにプログラムを書きたかったとしましょう。しかし、あなたはこのプログラムが単に一つの世界で固定サイズで動くことを望まないのです。あなたはどんな世界でも動くことができる単一のプログラムを書きたいと思います。</p>


<%
  include('templates/'+progLang+'/'+lang+'/programs/runnableWorldChoice.html', name="moveToWall", world="7x7", canvasWidth=300, ideSpeed=0.0)
%>


<p>世界の上にある[ワールドの変更]ドロップダウンをクリックして、ワールドを変更してみてください。それが壁にmoveまで、どんなサイズの世界でも、カレルはmoveするでしょう。この偉業はaを使って完成することはできないことに注意してください。 <code class="keyword">for</code> ループ。それは私達がプログラミングの時に世界の大きさを知ることを必要とするでしょう。</p>
<h3>基本的なWhileループ</h3>
<p>カレルでは、 <code class="keyword">while</code> ループはコード本体を繰り返すために使用されます<i>限り</i>与えられた条件が成り立ちます。 whileループの一般的な形式は次のとおりです。</p>
<p class="demoCode">
 <code><span class="keyword">while</span>(</code> <i class="demoText">テスト</i> <code>){</code> <br/>
<i class="demoText" style="margin-left:2em">繰り返す文</i><br/>
 <code>}</code> 
</p>
<p>whileループの制御フローは以下の通りです。プログラムがwhileループにぶつかると、最初のプロセスから繰り返し処理を開始します。<i>小切手</i>テストに合格した場合、そして合格した場合<i>run秒</i>本体内のコード</p>プログラムが<i>小切手</i>テストに合格した場合は、合格かどうかを判断します。<i class="demoText">テスト</i>世界の現在の状態に当てはまります。もしそうなら、ループはrunのコードをrunします。テストが失敗すると、ループは終了し、プログラムmoveがオンになります。
<p>プログラムが<i>run秒</i>ループの本体では、プログラムは本体の行を1つずつ実行します。プログラムがwhileループの最後に到達すると、ループの先頭に戻ります。テストを再チェックし、合格した場合はループを続けます。プログラムは、チェックが行われるまでループを終了せず、テストは失敗します。</p>
<p>カレルにはたくさんあります<i class="demoText">テスト</i>次の章でそれらすべてについて説明します。今のところ、単一のテストステートメントを使用します。 <code>frontIsClear()</code> カレルの真向かいに壁がない場合はこれが当てはまります。</p>
<h3>フェンスポストバグ</h3>
<p>上記のプログラムをもっと面白くなるように修正しましょう。壁に移動するのではなく、カレルにbeeper秒の線を各正方形に1つずつ配置させます。繰り返しになりますが、このプログラムはあらゆる規模の世界で機能します。</p>


<%
  include('templates/'+progLang+'/'+lang+'/programs/runnableWorldChoice.html', name="beeperLineBug1", world="7x7", canvasWidth=300, ideSpeed=0.0, isEditable="true")
%>


<p>それは素晴らしいですね。一つの問題を除いて。どの世界でもKarelはラインの最後のマスにbeeperを配置していません（よく見てください）。カレルが最後の正方形にあるとき、テストはもう合格しないので、プログラムはループの本体を実行しません - カレルは壁に面しています。あなたは、ビールを入れる前にKarel move sになるように体の順番をmoveうとしたくなるかもしれません。コードは編集可能なので、試してみてください。</p>
<p>体の再配置では解決できないという、より深い問題があります。 7列の世界では、Karelは7 beeper秒を置く必要がありますが、 move 6回だけでなければなりません。テストに合格すると、whileループが両方の行を実行するので、プログラムが1つのコマンドを他のコマンドよりも1回実行する方法を教えてください。</p>
<p>このプログラムのバグは、プログラムの問題の一例です。 <b>フェンスポストエラー</b> 。その名前は、どちらのサイズにもフェンスポストが1つあるパネルでできたフェンスを構築したい場合、フェンスポストの数は常にペインネルの数より1つ多いという事実に由来します。たとえば、10個のパネルでフェンスを建てるのに必要なフェンスポストはいくつありますか。次の図に示すように、答えは11です。</p>
<center>
<img src="{{pathToRoot}}images/ch6/fencepost.png" style="width:500px;margin-bottom:10px"/> 
</center>
<p>それを発見したら、このバグを修正するのは実はとても簡単です。カレルが世界の終わりでやめる前に、プログラムがしなければならないのは、最後のbeeperです。</p>


<%
  include('templates/java/'+lang+'/programs/runnableWorldChoice.html', name="beeperLine", world="7x7", canvasWidth=300, ideSpeed=0.8, isEditable="true")
%>
